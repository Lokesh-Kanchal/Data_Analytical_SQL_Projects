CREATE DATABASE SupplyChainFinanceManagement;

USE SupplyChainFinanceManagement;


/*-- 1. DIM_CUSTOMER table*/

CREATE TABLE DIM_CUSTOMER (
    CUSTOMER_CODE VARCHAR(50) PRIMARY KEY,
    CUSTOMER_NAME VARCHAR(255),
    MARKET VARCHAR(100),
    REGION VARCHAR(100),
    CUSTOMER_TYPE VARCHAR(100),
    ADDRESS VARCHAR(255),
    CITY VARCHAR(100),
    POSTAL_CODE VARCHAR(20)
);

INSERT INTO dim_customer (customer_code, customer_name, market, region, customer_type, address, city, postal_code)
VALUES
('C001', 'Croma', 'India', 'South Asia', 'Retailer', '123 MG Road', 'Mumbai', '400001'),
('C002', 'Reliance Digital', 'India', 'South Asia', 'Retailer', '456 Park Street', 'Delhi', '110001'),
('C003', 'Best Buy', 'USA', 'North America', 'Retailer', '789 Sunset Blvd', 'Los Angeles', '90001'),
('C004', 'Walmart', 'USA', 'North America', 'Retailer', '321 Broadway', 'New York', '10001');
SELECT * FROM DIM_CUSTOMER






/*-- 2. DIM_PRODUCT table*/

CREATE TABLE DIM_PRODUCT (
    PRODUCT_CODE VARCHAR(50) PRIMARY KEY,
    PRODUCT_NAME VARCHAR(255),
    VARIANT VARCHAR(100),
    PRODUCT_CATEGORY VARCHAR(100),
    PRODUCT_SUB_CATEGORY VARCHAR(100),
    BRAND VARCHAR(100),
    MANUFACTURER VARCHAR(100)
);
INSERT INTO dim_product
(product_code, product_name, variant, product_category, product_sub_category, brand, manufacturer)
VALUES
('P001', 'Wireless Mouse', 'Black', 'Accessories', 'Mouse', 'AtliQ', 'AtliQ Technologies'),
('P002', 'Mechanical Keyboard', 'RGB', 'Accessories', 'Keyboard', 'AtliQ', 'AtliQ Technologies'),
('P003', 'Gaming Laptop', 'i7', 'Computers', 'Laptop', 'AtliQ', 'AtliQ Technologies'),
('P004', 'Laser Printer', 'Color', 'Printers', 'Printer', 'AtliQ', 'AtliQ Technologies');
SELECT * FROM DIM_PRODUCT

/*CHECKING THE DATATYPE OF THE COLUMNS*/
SELECT COLUMN_NAME, DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME='DIM_PRODUCT'

/*-- 3. FACT_FORECAST_MONTHLY table*/

CREATE TABLE FACT_FORECAST_MONTHLY (
    FORECAST_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUSTOMER_CODE VARCHAR(50),
    PRODUCT_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    MONTH INT,
    FORECAST_QUANTITY INT,
    FORECAST_DATE DATE,
    FOREIGN KEY (CUSTOMER_CODE) REFERENCES DIM_CUSTOMER(CUSTOMER_CODE),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE)
);

INSERT INTO FACT_FORECAST_MONTHLY(
CUSTOMER_CODE,PRODUCT_CODE,FISCAL_YEAR,MONTH,FORECAST_QUANTITY,FORECAST_DATE)
VALUES
('C001', 'P001', 2023, 7, 500, '2023-07-01'),
('C002', 'P002', 2023, 7, 300, '2023-07-01'),
('C003', 'P003', 2023, 7, 150, '2023-07-01'),
('C004', 'P004', 2023, 7, 200, '2023-07-01')

SELECT * FROM FACT_FORECAST_MONTHLY



/*-- 4. FACT_FREIGHT_COST table*/

CREATE TABLE FACT_FREIGHT_COST (
    FREIGHT_ID INT IDENTITY(1,1) PRIMARY KEY,
    MARKET VARCHAR(100),
    FISCAL_YEAR INT,
    TOTAL_FREIGHT_COST DECIMAL(18,2),
    FREIGHT_PROVIDER VARCHAR(100),
    SHIPPING_MODE VARCHAR(100)
);
INSERT INTO fact_freight_cost (market, fiscal_year, total_freight_cost, freight_provider, shipping_mode)
VALUES
('India', 2023, 15000.50, 'DHL', 'Air'),
('USA', 2023, 25000.75, 'FedEx', 'Air'),
('India', 2024, 18000.00, 'BlueDart', 'Surface'),
('USA', 2024, 27000.25, 'UPS', 'Surface');

SELECT * FROM FACT_FREIGHT_COST





/*-- 5. FACT_GROSS_PRICE table*/

CREATE TABLE FACT_GROSS_PRICE (
    GROSS_PRICE_ID INT IDENTITY(1,1) PRIMARY KEY,
    PRODUCT_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    GROSS_PRICE DECIMAL(18,2),
    CURRENCY VARCHAR(10),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE)
);
INSERT INTO fact_gross_price (product_code, fiscal_year, gross_price, currency)
VALUES
('P001', 2023, 30.00, 'USD'),
('P002', 2023, 70.00, 'USD'),
('P003', 2023, 1200.00, 'USD'),
('P004', 2023, 300.00, 'USD');
SELECT * FROM FACT_GROSS_PRICE





/*-- 6. FACT_MANUFACTURING_COST table*/

CREATE TABLE FACT_MANUFACTURING_COST (
    MANUFACTURING_COST_ID INT IDENTITY(1,1) PRIMARY KEY,
    PRODUCT_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    MANUFACTURING_COST DECIMAL(18,2),
    MATERIAL_COST DECIMAL(18,2),
    LABOR_COST DECIMAL(18,2),
    OVERHEAD_COST DECIMAL(18,2),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE)
);
INSERT INTO fact_manufacturing_cost (product_code, fiscal_year, manufacturing_cost, material_cost, labor_cost, overhead_cost)
VALUES
('P001', 2023, 20.00, 10.00, 5.00, 5.00),
('P002', 2023, 45.00, 25.00, 10.00, 10.00),
('P003', 2023, 800.00, 500.00, 150.00, 150.00),
('P004', 2023, 200.00, 120.00, 40.00, 40.00);
SELECT * FROM FACT_MANUFACTURING_COST




/*-- 7. FACT_POST_INVOICE_DEDUCTIONS table*/

CREATE TABLE FACT_POST_INVOICE_DEDUCTIONS (
    POST_INVOICE_DEDUCTION_ID INT IDENTITY(1,1) PRIMARY KEY,
    PRODUCT_CODE VARCHAR(50),
    CUSTOMER_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    PROMOTIONAL_DISCOUNT DECIMAL(18,2),
    PLACEMENT_FEES DECIMAL(18,2),
    PERFORMANCE_REBATE DECIMAL(18,2),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE),
    FOREIGN KEY (CUSTOMER_CODE) REFERENCES DIM_CUSTOMER(CUSTOMER_CODE)
);
INSERT INTO fact_post_invoice_deductions (product_code, customer_code, fiscal_year, promotional_discount, placement_fees, performance_rebate)
VALUES
('P001', 'C001', 2023, 2.00, 1.00, 0.50),
('P002', 'C002', 2023, 3.00, 1.50, 1.00),
('P003', 'C003', 2023, 50.00, 20.00, 15.00),
('P004', 'C004', 2023, 10.00, 5.00, 4.00);
SELECT * FROM FACT_POST_INVOICE_DEDUCTIONS



/*-- 8. FACT_PRE_INVOICE_DEDUCTIONS table*/

CREATE TABLE FACT_PRE_INVOICE_DEDUCTIONS (
    PRE_INVOICE_DEDUCTION_ID INT IDENTITY(1,1) PRIMARY KEY,
    PRODUCT_CODE VARCHAR(50),
    CUSTOMER_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    PRE_INVOICE_DISCOUNT DECIMAL(18,2),
    DISCOUNT_TYPE VARCHAR(100),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE),
    FOREIGN KEY (CUSTOMER_CODE) REFERENCES DIM_CUSTOMER(CUSTOMER_CODE)
);
INSERT INTO fact_pre_invoice_deductions (product_code, customer_code, fiscal_year, pre_invoice_discount, discount_type)
VALUES
('P001', 'C001', 2023, 2.00, 'Annual Agreement'),
('P002', 'C002', 2023, 5.00, 'Annual Agreement'),
('P003', 'C003', 2023, 100.00, 'Annual Agreement'),
('P004', 'C004', 2023, 20.00, 'Annual Agreement');
SELECT * FROM FACT_PRE_INVOICE_DEDUCTIONS



/*-- 9. FACT_SALES_MONTHLY table*/

CREATE TABLE FACT_SALES_MONTHLY (
    SALES_ID INT IDENTITY(1,1) PRIMARY KEY,
    CUSTOMER_CODE VARCHAR(50),
    PRODUCT_CODE VARCHAR(50),
    FISCAL_YEAR INT,
    MONTH INT,
    SOLD_QUANTITY INT,
    SALES_AMOUNT DECIMAL(18,2),
    SALES_DATE DATE,
    FOREIGN KEY (CUSTOMER_CODE) REFERENCES DIM_CUSTOMER(CUSTOMER_CODE),
    FOREIGN KEY (PRODUCT_CODE) REFERENCES DIM_PRODUCT(PRODUCT_CODE)
);
INSERT INTO fact_sales_monthly (customer_code, product_code, fiscal_year, month, sold_quantity, sales_amount, sales_date)
VALUES
('C001', 'P001', 2023, 7, 450, 12600.00, '2023-07-15'),
('C002', 'P002', 2023, 7, 280, 19600.00, '2023-07-15'),
('C003', 'P003', 2023, 7, 130, 156000.00, '2023-07-15'),
('C004', 'P004', 2023, 7, 180, 54000.00, '2023-12-15');

/*DROP TABLE fact_sales_monthly*/

SELECT * FROM FACT_SALES_MONTHLY



/* TABLE- 10 CUSTOMER FEEDBACK TABLE*/

CREATE TABLE FACT_CUSTOMER_FEEDBACK (
    CUSTOMER_CODE VARCHAR(50) PRIMARY KEY,
    FEEDBACK_SCORE FLOAT NOT NULL,
    FEEDBACK_DATE DATE,
);
INSERT INTO FACT_CUSTOMER_FEEDBACK (CUSTOMER_CODE,FEEDBACK_SCORE,FEEDBACK_DATE)
VALUES
('C001',4.5,'2023-07-15'),
('C002',4.0,'2023-07-16'),
('C003',3.0,'2023-07-17'),
('C004',5.5,'2023-07-18')

SELECT * FROM FACT_CUSTOMER_FEEDBACK


INSERT INTO dim_customer (customer_code, customer_name, market, region, customer_type, address, city, postal_code)
VALUES
('C001', 'Croma', 'India', 'South Asia', 'Retailer', '123 MG Road', 'Mumbai', '400001'),
('C002', 'Reliance Digital', 'India', 'South Asia', 'Retailer', '456 Park Street', 'Delhi', '110001'),
('C003', 'Best Buy', 'USA', 'North America', 'Retailer', '789 Sunset Blvd', 'Los Angeles', '90001'),
('C004', 'Walmart', 'USA', 'North America', 'Retailer', '321 Broadway', 'New York', '10001');
SELECT * FROM DIM_CUSTOMER




/*Task-3*/

/*Q1) Assume calendar_date is '2023-07-15'. Apply the function to
this date and explain what value it will return as the fiscal year.*/

/*This is the as per the sales date. Let's go as per the statement*/
SELECT customer_code, product_code, product_code,
CASE
WHEN MONTH(SALES_DATE)>=9 THEN YEAR(SALES_DATE) + 1
ELSE YEAR(SALES_DATE)
END AS FISCALS_YEARS
FROM FACT_SALES_MONTHLY

SELECT *,
CASE
WHEN MONTH('2023-07-15')>=9 THEN YEAR ('2023-07-15')+1
ELSE
YEAR('2023-07-15')
END AS FISCAL_YEARS
FROM FACT_SALES_MONTHLY



/*Q2) Analyzing Gross Sales: Monthly Product Transactions
Report
Write a Query for making report on monthly product
transactions, including details such as date, product code,
product name, variant, sold quantity, gross price, and gross price
total. The query should involves joining several tables and
filtering results based on customer code and fiscal year.*/

SELECT * FROM DIM_CUSTOMER
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_FORECAST_MONTHLY
SELECT * FROM FACT_FREIGHT_COST
SELECT * FROM FACT_GROSS_PRICE
SELECT * FROM FACT_MANUFACTURING_COST
SELECT * FROM FACT_POST_INVOICE_DEDUCTIONS
SELECT * FROM FACT_PRE_INVOICE_DEDUCTIONS
SELECT * FROM FACT_SALES_MONTHLY

/*PRODUCT TABLE, ( product code,product name, variant,)  (PRODUCT CODE LINK TABLE)
FACT_GROSS_PRICE (gross price, and gross price total) PRODUCT CODE LINK TABLE)
FACT_SALES_MONTHLY (SALES date, sold quantity) PRODUCT CODE LINK TABLE)
*/
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_GROSS_PRICE
SELECT * FROM FACT_SALES_MONTHLY

SELECT DP.PRODUCT_CODE,
DP.PRODUCT_NAME,
DP.VARIANT,
FSM.SALES_DATE AS TRANSACTION_DATE,
FSM.SOLD_QUANTITY,
FGP.GROSS_PRICE, 
(FGP.GROSS_PRICE*FSM.SOLD_QUANTITY) AS GROSS_PRICE_TOTAL
FROM DIM_PRODUCT DP
INNER JOIN 
FACT_SALES_MONTHLY FSM ON DP.PRODUCT_CODE=FSM.PRODUCT_CODE
INNER JOIN
FACT_GROSS_PRICE FGP ON FSM.PRODUCT_CODE=FGP.PRODUCT_CODE
AND FSM.FISCAL_YEAR=FGP.FISCAL_YEAR
WHERE FSM.CUSTOMER_CODE='C001' AND FSM.FISCAL_YEAR=2023





/*Task-4*/
SELECT * FROM FACT_SALES_MONTHLY

/*Sales Trend Analysis:
Query the fact_monthly_sales table to identify the monthly sales
trend for each product. How do the sales volumes fluctuate over
time?*/

SELECT * FROM FACT_SALES_MONTHLY

SELECT CUSTOMER_CODE, PRODUCT_CODE,
FISCAL_YEAR,MONTH,
SUM(SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY
FROM FACT_SALES_MONTHLY
GROUP BY CUSTOMER_CODE, PRODUCT_CODE, FISCAL_YEAR,MONTH
ORDER BY PRODUCT_CODE DESC



SELECT CUSTOMER_CODE, PRODUCT_CODE,
FISCAL_YEAR,MONTH
FROM FACT_SALES_MONTHLY
GROUP BY CUSTOMER_CODE, PRODUCT_CODE, FISCAL_YEAR,MONTH
ORDER BY PRODUCT_CODE DESC


/*Customer Segmentation:

Utilizing the dim_customer table, segment customers based on
their purchasing behavior. Which customer segments contribute
the most to sales revenue?*/

SELECT * FROM DIM_CUSTOMER
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM FACT_FREIGHT_COST

SELECT DC.CUSTOMER_CODE,FSM.PRODUCT_CODE,DP.PRODUCT_NAME, DP.PRODUCT_CATEGORY,
(FSM.SOLD_QUANTITY*FSM.SALES_AMOUNT) AS TOTAL_SALESS
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC ON FSM.CUSTOMER_CODE=DC.CUSTOMER_CODE
INNER JOIN DIM_PRODUCT DP ON FSM.PRODUCT_CODE=DP.PRODUCT_CODE
GROUP BY DC.CUSTOMER_CODE,DC.CUSTOMER_CODE,FSM.PRODUCT_CODE,(FSM.SOLD_QUANTITY*FSM.SALES_AMOUNT),
DP.PRODUCT_NAME, DP.PRODUCT_CATEGORY
ORDER BY 
TOTAL_SALESS DESC


/*Product Performance Comparison:

Compare the performance of products in terms of sales quantity
and revenue generated. Which products are the top performers,
and which ones need improvement?*/

SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY

/*SOLUTION 1*/

SELECT DP.PRODUCT_CODE, DP.PRODUCT_NAME, SUM(FSM.SOLD_QUANTITY) AS TOTAL_SALES_QUANTITY,
SUM(SALES_AMOUNT) AS TOTAL_REVENUE
FROM DIM_PRODUCT DP
INNER JOIN FACT_SALES_MONTHLY FSM ON DP.PRODUCT_CODE=FSM.PRODUCT_CODE
GROUP BY
DP.PRODUCT_CODE, DP.PRODUCT_NAME
ORDER BY
TOTAL_REVENUE DESC

/*SOLUTION 2*/

SELECT DP.PRODUCT_CODE, DP.PRODUCT_NAME, FSM.SOLD_QUANTITY, SUM(FSM.SOLD_QUANTITY*FSM.SALES_AMOUNT) AS TOTAL_SALES_REVENUE
FROM DIM_PRODUCT DP
INNER JOIN FACT_SALES_MONTHLY FSM ON DP.PRODUCT_CODE=FSM.PRODUCT_CODE
GROUP BY
DP.PRODUCT_CODE, DP.PRODUCT_NAME,FSM.SOLD_QUANTITY, (FSM.SOLD_QUANTITY*FSM.SALES_AMOUNT)
ORDER BY
TOTAL_SALES_REVENUE ASC, FSM.SOLD_QUANTITY ASC


/*Market Expansion Opportunities:

Analyze the fact_forecast_monthly table to identify potential
market expansion opportunities. Which markets show the highest
forecasted demand growth?*/

SELECT * FROM FACT_FORECAST_MONTHLY
SELECT * FROM DIM_CUSTOMER

SELECT FFM.FORECAST_ID, DM.MARKET, DM.REGION, 
SUM(FFM.FORECAST_QUANTITY) OVER (PARTITION BY DM.MARKET) AS TOTAL_MARKET_FORECAST
FROM FACT_FORECAST_MONTHLY FFM
INNER JOIN DIM_CUSTOMER DM ON FFM.CUSTOMER_CODE=DM.CUSTOMER_CODE
ORDER BY TOTAL_MARKET_FORECAST ASC


/*GROUP BY FFM.FORECAST_ID, DM.MARKET, DM.REGION
*/




/*Cost Analysis:

Calculate the total manufacturing cost for each product and
compare it with the gross price to determine profitability. Which
products have the highest profit margins?*/

SELECT * FROM FACT_MANUFACTURING_COST
SELECT * FROM FACT_GROSS_PRICE

SELECT FMC.PRODUCT_CODE, FMC.MANUFACTURING_COST, FGP.GROSS_PRICE, 
(FGP.GROSS_PRICE-FMC.MANUFACTURING_COST) AS PROFIT_MARGIN
FROM FACT_MANUFACTURING_COST FMC
INNER JOIN FACT_GROSS_PRICE FGP
ON FMC.PRODUCT_CODE= FGP.PRODUCT_CODE
GROUP BY FMC.PRODUCT_CODE, FMC.MANUFACTURING_COST, FGP.GROSS_PRICE, 
(FGP.GROSS_PRICE-FMC.MANUFACTURING_COST)
ORDER BY 
PROFIT_MARGIN DESC



/*Discount Impact Analysis:

Assess the impact of pre-invoice discounts on sales revenue.
How do varying discount levels affect overall revenue and
customer retention?*/

SELECT FPID.PRODUCT_CODE,DC.CUSTOMER_NAME,
COUNT( DISTINCT FSM.SALES_DATE) AS MONTHS_ACTIVE,
AVG(FPID.PRE_INVOICE_DISCOUNT) AS AVERAGE_DISCOUNT,
SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES_AMOUNT
FROM FACT_PRE_INVOICE_DEDUCTIONS FPID
INNER JOIN FACT_SALES_MONTHLY FSM 
ON FSM.PRODUCT_CODE= FPID.PRODUCT_CODE
INNER JOIN DIM_CUSTOMER DC ON DC.CUSTOMER_CODE= FPID.CUSTOMER_CODE
GROUP BY FPID.PRODUCT_CODE,CUSTOMER_NAME
ORDER BY AVERAGE_DISCOUNT DESC




/*Market-specific Freight Costs:

Determine the average freight costs for different markets over
the years. Are there any noticeable trends or outliers in freight
expenses?*/

SELECT * FROM FACT_FREIGHT_COST 

SELECT  FFC.FISCAL_YEAR,FFC.MARKET, FFC.SHIPPING_MODE,
AVG(FFC.TOTAL_FREIGHT_COST) AS AVERAGE_FREIGHT_COST
FROM FACT_FREIGHT_COST FFC
GROUP BY FFC.FISCAL_YEAR,FFC.MARKET,FFC.SHIPPING_MODE
ORDER BY AVERAGE_FREIGHT_COST DESC




/*Seasonal Sales Patterns:

Explore the fact_monthly_sales table to identify seasonal sales
patterns. How do sales volumes vary throughout the year, and
are there any recurring trends?*/
SELECT * FROM FACT_SALES_MONTHLY

SELECT MONTH,CUSTOMER_CODE, SUM(SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY
FROM FACT_SALES_MONTHLY
GROUP BY MONTH, CUSTOMER_CODE
ORDER BY MONTH


/*Customer Loyalty Analysis:


Analyze customer purchase frequency and retention rates over
time. Which customers exhibit the highest levels of loyalty, and
how can their behavior be leveraged for targeted marketing
campaigns?*/

SELECT * FROM DIM_CUSTOMER
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY

SELECT FSM.CUSTOMER_CODE,DC.CUSTOMER_NAME,DC.CITY,COUNT(DISTINCT FSM.SALES_DATE) AS PURCHASE_DAYS,
COUNT(DISTINCT MONTH) AS ACTIVE_MONTH,
COUNT(*) AS TOTAL_TRANSACTION
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC
ON 
FSM.CUSTOMER_CODE=DC.CUSTOMER_CODE
GROUP BY FSM.CUSTOMER_CODE,DC.CUSTOMER_NAME,DC.CITY 
ORDER BY TOTAL_TRANSACTION




/*Forecast Accuracy Evaluation:

Evaluate the accuracy of sales forecasts by comparing forecasted
quantities with actual sales data. Are there any significant
discrepancies, and how can forecast models be improved?*/

SELECT * FROM FACT_FORECAST_MONTHLY
SELECT * FROM FACT_SALES_MONTHLY


SELECT 
	FFM.PRODUCT_CODE,
	SUM(FFM.FORECAST_QUANTITY) AS TOTAL_FORECAST_QUANTITY,
	SUM(FSM.SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY,
	SUM(FFM.FORECAST_QUANTITY-FSM.SOLD_QUANTITY) AS SOLD_QUANTITY_DIFFERENCE
FROM 
	FACT_FORECAST_MONTHLY FFM
INNER JOIN 
	FACT_SALES_MONTHLY FSM 
ON 
	FFM.PRODUCT_CODE= FSM.PRODUCT_CODE
GROUP BY FFM.PRODUCT_CODE
ORDER BY SOLD_QUANTITY_DIFFERENCE DESC



/*Channel Performance Assessment:

Compare sales performance across different sales channels (e.g.,
E-Commerce vs. Brick & Mortar). Which channels are most
effective in driving sales, and are there any opportunities for
optimization?*/

/*CHOOSE CUSTOMER_TYPE AS SALES_CHANNEL*/
SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY

SELECT DC.CUSTOMER_NAME, DC.MARKET,DC.CUSTOMER_TYPE AS SALES_CHANNEL,
SUM(FSM.SOLD_QUANTITY*FSM.SALES_AMOUNT) AS TOTAL_SALES_REVENUE
FROM DIM_CUSTOMER DC
inner join FACT_SALES_MONTHLY FSM ON 
DC.CUSTOMER_CODE=FSM.CUSTOMER_CODE
GROUP BY DC.CUSTOMER_NAME, DC.MARKET, DC.CUSTOMER_TYPE
ORDER BY TOTAL_SALES_REVENUE DESC



/*Geographical Sales Distribution:

Analyze sales distribution across different geographical regions.
How does sales performance vary by region, and are there any
emerging markets worth focusing on?*/

SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY

SELECT DC.REGION,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY, SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES_REVENUE,
COUNT(DISTINCT FSM.CUSTOMER_CODE) AS ACTIVE_CUSTOMER
FROM DIM_CUSTOMER DC
INNER JOIN FACT_SALES_MONTHLY FSM
ON DC.CUSTOMER_CODE=FSM.CUSTOMER_CODE
GROUP BY DC.REGION
ORDER BY
TOTAL_SALES_REVENUE DESC



/*Customer Acquisition Cost Analysis:
 
Calculate the customer acquisition cost (CAC) for each market
and channel. Which acquisition channels provide the highest
return on investment (ROI), and where should resources be
allocated for customer acquisition?*/


SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY


SELECT DC.MARKET, DC.CUSTOMER_TYPE AS CHANNEL,
COUNT(DISTINCT DC.CUSTOMER_CODE) AS TOTAL_CUSTOMER,
COUNT(DISTINCT DC.CUSTOMER_CODE)*1000 AS ESTIMATE_ACQUISITION_COST,
SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES_REVENUE,
ROUND(COUNT(DISTINCT DC.CUSTOMER_CODE)*1000/COUNT(DISTINCT DC.CUSTOMER_CODE),2)
AS CUSTOMER_ACQUISITION_COST,
ROUND( 
(SUM(FSM.SALES_AMOUNT)-(COUNT(DISTINCT DC.CUSTOMER_CODE)*1000))*100/
NULLIF((COUNT(DISTINCT DC.CUSTOMER_CODE)*1000),0),2)
AS RETURN_ON_INVESTMENT_PERCENTAGE
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC
ON FSM.CUSTOMER_CODE=DC.CUSTOMER_CODE
GROUP BY DC.MARKET, DC.CUSTOMER_TYPE
ORDER BY
RETURN_ON_INVESTMENT_PERCENTAGE


/* AS PER ABOVE SOLUTION, AS WE DON'T HAVE ESTIMATE_ACQUISITION_COST COLUMN SO WE TOOK 
	COUNT(DISTINCT DC.CUSTOMER_CODE)*1000 AS ESTIMATE_ACQUISITION_COST 
	CAC: 	How much it costs to acquire a new customer
	ROI: 	Return = (Revenue - Cost) / Cost   — usually shown as a %
*/



/*Product Mix Optimization:

Determine the optimal product mix based on sales volume,
profitability, and market demand. How can product portfolios be
adjusted to maximize overall revenue?*/

SELECT * FROM FACT_SALES_MONTHLY  /*has sold quantity and sales amount*/
SELECT * FROM FACT_GROSS_PRICE   /*has gross price per product*/
SELECT * FROM DIM_PRODUCT  /*product details*/

/*Profitability = (gross_price - sales price per unit) × quantity*/

SELECT
DP.PRODUCT_CODE,
DP.PRODUCT_NAME, 
DP.VARIANT,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY,
SUM(FSM.SALES_AMOUNT) AS TOTAL_REVENUE,
AVG(FGP.GROSS_PRICE) AS AVERAGE_GROSS_PRICE,
ROUND(
SUM((FGP.GROSS_PRICE- FSM.SALES_AMOUNT*1.0/NULLIF (FSM.SOLD_QUANTITY, 0))*FSM.SOLD_QUANTITY),
2)
AS TOTAL_MARGIN
FROM FACT_SALES_MONTHLY FSM
INNER JOIN
DIM_PRODUCT DP ON
FSM.PRODUCT_CODE=DP.PRODUCT_CODE
INNER JOIN FACT_GROSS_PRICE FGP ON FSM.PRODUCT_CODE=FGP.PRODUCT_CODE
GROUP BY DP.PRODUCT_CODE,
DP.PRODUCT_NAME, 
DP.VARIANT
ORDER BY
TOTAL_MARGIN



/*Customer Lifetime Value Calculation:

Calculate the customer lifetime value (CLV) for each customer
segment. Which segments are the most valuable in terms of
long-term revenue generation?*/

/*CLV(customer lifetime value) = Average Monthly Revenue × Number of Active Months*/

SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM DIM_CUSTOMER

SELECT 
DC.CUSTOMER_NAME,
DC.CUSTOMER_TYPE AS SEGMENT,
COUNT(DISTINCT DC.CUSTOMER_CODE) AS TOTAL_CUSTOMER,
SUM(FSM.SALES_AMOUNT) AS TOTAL_REVENUE,
ROUND(SUM(FSM.SALES_AMOUNT)*1.0/COUNT(DISTINCT DC.CUSTOMER_CODE),2)
AS AVERAGE_CLV
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC
ON FSM.CUSTOMER_CODE= DC.CUSTOMER_CODE
GROUP BY 
DC.CUSTOMER_NAME,
DC.CUSTOMER_TYPE 
ORDER BY 
AVERAGE_CLV

/** 1.0
What it does: Forces SQL to treat the math as a decimal (float) division instead of integer division.
Why it's used: If you divide two integers in SQL Server, it returns an integer (e.g., 5/2 = 2).
But 5 * 1.0 / 2 = 2.5 — this ensures accurate average calculations.*/



/*Inventory Management Analysis:

Analyze inventory turnover rates and identify slow-moving or
obsolete products. How can inventory management practices be
optimized to reduce carrying costs and improve cash flow?*/

SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM FACT_GROSS_PRICE

/*Turnover Rate = Total Sold Quantity / Assumed Average Inventory*/
/* CAST(... AS DECIMAL(10, 2))
Converts the result from a FLOAT (which may show 130.0000000)
into a fixed-point number like 130.00.*/

SELECT DP.PRODUCT_NAME, DP.PRODUCT_CATEGORY,DP.VARIANT,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_UNIT_SOLD,
COUNT(DISTINCT FSM.SALES_DATE ) AS ACTIVE_MONTH,
CAST(
ROUND(SUM(FSM.SOLD_QUANTITY)*1.0/NULLIF(COUNT(DISTINCT FSM.SALES_DATE),0),2)
AS DECIMAL(10,2)
)
AS MONTHLY_TURNOVER
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_PRODUCT DP ON 
FSM.PRODUCT_CODE = DP.PRODUCT_CODE
GROUP BY DP.PRODUCT_NAME, DP.PRODUCT_CATEGORY,DP.VARIANT
ORDER BY MONTHLY_TURNOVER






/*Competitor Benchmarking:

Compare sales performance with competitors in the same market
segments. How does your company's market share and growth
rate compare to industry benchmarks?*/

/*According to the above query, we need internal sales data which we can collect from FACT_SALES_MONTHLY and
DIM_CUSTOMER table. 
For the Industry or competitor sales data : it is required for external benchmarking report and assumptions, 
so for this we will create a  temporary in-memory table called IndustryBenchmarks*/


/*Combines the first row with another row you're adding below.
ALL ensures that duplicates are not removed (useful for performance and when you want all data as-is).*/

SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM DIM_CUSTOMER



WITH INDUSTRY_BENCHMARKS AS (
SELECT 'INDIA' AS MARKET, 'RETAIL' AS CHANNEL, 300000 AS TOTAL_INDUSTRY_REVENUE
UNION ALL
SELECT 'USA', 'RETAIL', 200000
) 
/*SELECT * FROM INDUSTRY_BENCHMARKS*/
SELECT 
C.MARKET, C.CHANNEL, 
I.TOTAL_INDUSTRY_REVENUE,
ROUND(C.COMPANY_SALES*100.0/ I.TOTAL_INDUSTRY_REVENUE,2) AS MKT_SHARE_PERCENTAGE
FROM
(
SELECT DC.MARKET, DC.CUSTOMER_TYPE AS CHANNEL,
SUM(FSM.SALES_AMOUNT) AS COMPANY_SALES
FROM
FACT_SALES_MONTHLY FSM
INNER JOIN 
DIM_CUSTOMER DC ON FSM.CUSTOMER_CODE=DC.CUSTOMER_CODE
GROUP BY 
DC.MARKET, DC.CUSTOMER_TYPE
) C   /* ASSIGN THIS ONE AS A TABLE C*/
JOIN 
INDUSTRY_BENCHMARKS I 
ON LOWER(I.MARKET)=LOWER(C.MARKET)  AND LOWER(C.CHANNEL)=LOWER(I.CHANNEL)
ORDER BY MKT_SHARE_PERCENTAGE 


/*Price Elasticity Estimation:

Assess the price elasticity of demand for different product
categories. How sensitive are sales volumes to changes in
product prices, and what pricing strategies can be implemented
to maximize revenue?*/

SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM FACT_GROSS_PRICE


SELECT DP.PRODUCT_CATEGORY,FSM.PRODUCT_CODE,
FSM.FISCAL_YEAR,FSM.MONTH,
SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_QUANTITY,
CAST(ROUND(AVG(FGP.GROSS_PRICE),2) AS DECIMAL(10,2)
)AS AVG_GROSS_PRICE
FROM 
FACT_SALES_MONTHLY FSM
INNER JOIN 
DIM_PRODUCT DP
ON FSM.PRODUCT_CODE=DP.PRODUCT_CODE 
INNER JOIN 
FACT_GROSS_PRICE FGP ON FSM.PRODUCT_CODE= FGP.PRODUCT_CODE
AND FGP.FISCAL_YEAR= FSM.FISCAL_YEAR
GROUP BY FSM.PRODUCT_CODE,DP.PRODUCT_CATEGORY,
FSM.FISCAL_YEAR,FSM.MONTH
ORDER BY TOTAL_SALES DESC



SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM FACT_CUSTOMER_FEEDBACK

/*Customer Satisfaction Analysis:

Utilize customer feedback data to assess overall satisfaction
levels and identify areas for improvement. How do customer
satisfaction scores correlate with sales performance?*/


SELECT 
DC.CUSTOMER_CODE,DC.CUSTOMER_TYPE,DC.MARKET,DC.REGION,
ROUND(AVG(FCF.FEEDBACK_SCORE),2) AS AVG_FEEDBACK_SCORE,
SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES_AMOUNT,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY
FROM 
FACT_CUSTOMER_FEEDBACK FCF
INNER JOIN FACT_SALES_MONTHLY FSM ON FCF.CUSTOMER_CODE= FSM.CUSTOMER_CODE
INNER JOIN DIM_CUSTOMER DC ON FCF.CUSTOMER_CODE=DC.CUSTOMER_CODE
GROUP BY 
DC.CUSTOMER_CODE,DC.CUSTOMER_TYPE,DC.MARKET,DC.REGION
ORDER BY
AVG_FEEDBACK_SCORE DESC



/*Task-5*/

/*
1. Define a user-defined function to calculate the total
forecasted quantity for a given product and fiscal year.*/
SELECT * FROM FACT_FORECAST_MONTHLY


CREATE FUNCTION GETTOTALFORECASTQUANTITY
(
@PRODUCT_CODE VARCHAR(50),
@FISCALYEAR INT
)
RETURNS INT
AS 
BEGIN 
DECLARE @TOTALFOERCAST INT;
SELECT @TOTALFOERCAST= SUM(FORECAST_QUANTITY)
FROM FACT_FORECAST_MONTHLY
WHERE PRODUCT_CODE= @PRODUCT_CODE
AND FISCAL_YEAR=@FISCALYEAR
RETURN ISNULL(@TOTALFOERCAST,0);
END;

SELECT * FROM FACT_FORECAST_MONTHLY
SELECT DBO.GETTOTALFORECASTQUANTITY('P002',2023) AS TOTALFORECAST;


SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY 
/*2. Write a query to find the customers who made purchases
exceeding the average monthly sales quantity across all
products.*/

SELECT SUM(FSM.SOLD_QUANTITY) TOTAL_SOLD_QTY,
DC.CUSTOMER_CODE,DC.CUSTOMER_NAME,DC.CUSTOMER_TYPE
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC
ON FSM.CUSTOMER_CODE=DC.CUSTOMER_CODE
GROUP BY DC.CUSTOMER_CODE,DC.CUSTOMER_NAME,DC.CUSTOMER_TYPE
HAVING SUM(FSM.SOLD_QUANTITY)> 
(SELECT AVG(SOLD_QUANTITY) FROM FACT_SALES_MONTHLY)





/*3. Create a stored procedure to update the gross price of a
product for a specific fiscal year*/

CREATE PROCEDURE UPDATE_GROSS_PRICE 
@PRODUCTCODE VARCHAR(50),
@FISCALYEAR INT,
@GROSSPRICE DECIMAL(8,2)
AS 
BEGIN
UPDATE FACT_GROSS_PRICE
SET GROSS_PRICE=@GROSSPRICE
WHERE 
FISCAL_YEAR=@FISCALYEAR
AND PRODUCT_CODE=@PRODUCTCODE;

IF @@ROWCOUNT=0
BEGIN 
PRINT 'NO RECORDS WERE UPDATED. PLEASE CHECK FISCAL YEAR, PRODUCT CODE.'
END
ELSE
BEGIN
PRINT 'GROSS PRICE UPDATED SUCCESSFULLY';
END
END;

DROP PROCEDURE UPDATE_GROSS_PRICE; 

EXEC UPDATE_GROSS_PRICE 'P001',2023,50;

SELECT * FROM FACT_GROSS_PRICE 
WHERE PRODUCT_CODE='P001'





/*4. Implement a trigger that automatically inserts a record into
the audit log table whenever a new entry is added to the
sales table.*/


/*STEP 1: CREATE SALES AUDIT TABLE*/
CREATE TABLE SALES_AUDIT_LOG(
AUDIT_ID INT IDENTITY(1,1) PRIMARY KEY,
SALES_ID INT,
CUSTOMER_CODE VARCHAR(50),
PRODUCT_CODE VARCHAR(50),
FISCAL_YEAR INT,
MONTH INT,
SOLD_QUANTITY INT,
SALES_AMOUNT DECIMAL(18,2),
SALES_DATE DATE,
INSERTED_AT DATETIME DEFAULT GETDATE()
);

SELECT * FROM SALES_AUDIT_LOG
/*STEP 2: CREATE TRIGGERS*/

CREATE TRIGGER TRG_INSERTED_SALESAUDIT
ON FACT_SALES_MONTHLY
AFTER INSERT 
AS
BEGIN 
INSERT INTO SALES_AUDIT_LOG
(SALES_ID, CUSTOMER_CODE, PRODUCT_CODE, FISCAL_YEAR, MONTH, SOLD_QUANTITY, SALES_AMOUNT, SALES_DATE)
SELECT
SALES_ID, CUSTOMER_CODE, PRODUCT_CODE, FISCAL_YEAR, MONTH, SOLD_QUANTITY, SALES_AMOUNT, SALES_DATE
FROM inserted;
END;


 INSERT INTO FACT_SALES_MONTHLY (
 CUSTOMER_CODE, PRODUCT_CODE, FISCAL_YEAR, MONTH, SOLD_QUANTITY, SALES_AMOUNT, SALES_DATE
 )
 VALUES ('C001', 'P001', 2024, 8, 250, 2500.00, '2023-04-10');

 SELECT * FROM SALES_AUDIT_LOG

 

 /*5. Use a window function to rank products based on their
monthly sales quantity, partitioned by fiscal year.*/
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_SALES_MONTHLY

/*USING RANK() WINDOWS FUNCTION*/
SELECT FSM.FISCAL_YEAR,FSM.MONTH, FSM.PRODUCT_CODE, FSM.SOLD_QUANTITY,
RANK() 
OVER 
(
PARTITION BY 
FSM.FISCAL_YEAR, MONTH
ORDER BY 
FSM.SOLD_QUANTITY DESC
)
AS PRODUCT_RANK
FROM FACT_SALES_MONTHLY FSM



/*USING DENSE_RANK()*/
SELECT FSM.FISCAL_YEAR,FSM.MONTH, FSM.PRODUCT_CODE, FSM.SOLD_QUANTITY,
DENSE_RANK() 
OVER 
(
PARTITION BY 
FSM.FISCAL_YEAR, MONTH
ORDER BY 
FSM.SOLD_QUANTITY DESC
)
AS PRODUCT_RANK
FROM FACT_SALES_MONTHLY FSM




/*6. Utilize the STRING_AGG function to concatenate the
names of all customers who purchased a specific product
within a given timeframe.*/

SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY

SELECT FSM.PRODUCT_CODE, STRING_AGG(DC.CUSTOMER_NAME, ' , ') 
AS CUSTOMER_LIST
FROM 
DIM_CUSTOMER DC
INNER JOIN 
FACT_SALES_MONTHLY FSM
ON 
DC.CUSTOMER_CODE=FSM.CUSTOMER_CODE
WHERE FSM.PRODUCT_CODE='P001' 
AND FSM.FISCAL_YEAR BETWEEN '2023' AND '2024'
GROUP BY FSM.PRODUCT_CODE






/*7. Develop a user-defined function that calculates the total
manufacturing cost for a product over a specified range of
years, using a subquery to retrieve the necessary data.*/

SELECT * FROM FACT_MANUFACTURING_COST


CREATE FUNCTION GETTOTAL_MANUFACTURING_COST
(
@PRODUCTCODE VARCHAR(50),
@STARTYEAR INT,
@ENDYEAR INT
)
RETURNS DECIMAL(8,2)
AS
BEGIN
DECLARE @TOTALCOST DECIMAL(8,2)
SELECT @TOTALCOST=
(SELECT SUM(MANUFACTURING_COST) FROM FACT_MANUFACTURING_COST
WHERE PRODUCT_CODE= @PRODUCTCODE
AND FISCAL_YEAR BETWEEN @STARTYEAR AND @ENDYEAR
)
RETURN ISNULL (@TOTALCOST,0)
END;


SELECT DBO.GETTOTAL_MANUFACTURING_COST('P001',2021, 2023)
AS 
TOTALCOST;



/* 
9. Apply the LEAD or LAG function to compare monthly
sales quantities of a product with the previous month's
sales..*/
SELECT * FROM FACT_SALES_MONTHLY

SELECT PRODUCT_CODE, FISCAL_YEAR, MONTH,SOLD_QUANTITY,
LAG(SOLD_QUANTITY) OVER (PARTITION BY PRODUCT_CODE,
FISCAL_YEAR
ORDER BY MONTH) AS PREVIOUS_YEAR_SALES,
SOLD_QUANTITY-LAG(SOLD_QUANTITY) OVER (PARTITION BY PRODUCT_CODE,
FISCAL_YEAR
ORDER BY MONTH) AS QUANTITY_DIFFERENCE
FROM FACT_SALES_MONTHLY
WHERE PRODUCT_CODE='P001' AND MONTH=7
ORDER BY PRODUCT_CODE, FISCAL_YEAR


SELECT PRODUCT_CODE, FISCAL_YEAR, MONTH,SOLD_QUANTITY,
LEAD(SOLD_QUANTITY) OVER (PARTITION BY PRODUCT_CODE,
FISCAL_YEAR
ORDER BY MONTH) 
AS NEXT_YEAR_SALES,
LEAD(SOLD_QUANTITY) OVER (PARTITION BY PRODUCT_CODE,
FISCAL_YEAR
ORDER BY MONTH)-SOLD_QUANTITY AS QUANTITY_DIFFERENCE
FROM FACT_SALES_MONTHLY
WHERE PRODUCT_CODE='P001' AND MONTH=7
ORDER BY PRODUCT_CODE, FISCAL_YEAR





/*10. Create a query to identify the top-selling products in
each market based on their total sales quantity, utilizing
subqueries and window functions.*/


/*WITHOUT WINDOWS AND SUBQUERY FUNCTION ON THE BASE OF MARKET AND PRODUCT CODE*/

SELECT DC.MARKET,FSM.PRODUCT_CODE,
SUM(FSM.SOLD_QUANTITY) AS TOTAL_SOLD_QUANTITY
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC 
ON FSM.CUSTOMER_CODE= DC.CUSTOMER_CODE
GROUP BY DC.MARKET, FSM.PRODUCT_CODE
ORDER BY DC.MARKET, TOTAL_SOLD_QUANTITY DESC;

/*WITH USING OF WINDOWS FUNCTION AND SUBQUERY*/
SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY

WITH PRODUCT_SALES AS
(
SELECT DC.MARKET, FSM.PRODUCT_CODE,
SUM(FSM.SOLD_QUANTITY) TOTAL_SOLD_QUANTITY
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC 
ON FSM.CUSTOMER_CODE= DC.CUSTOMER_CODE
GROUP BY DC.MARKET, FSM.PRODUCT_CODE
),
PRODUCT_RANK_TABLE AS 
(
SELECT MARKET, PRODUCT_CODE,TOTAL_SOLD_QUANTITY,
RANK() OVER (PARTITION BY MARKET ORDER BY TOTAL_SOLD_QUANTITY DESC) AS SALES_RANK
FROM PRODUCT_SALES
)
SELECT MARKET, PRODUCT_CODE, TOTAL_SOLD_QUANTITY
FROM PRODUCT_RANK_TABLE
WHERE SALES_RANK=1;



/*11. Develop a user-defined function to calculate the total
freight cost for a product based on its market and fiscal
year. Then, integrate this function into a stored procedure to
update the overall cost.*/

/*SOLUTION STRETEGY*/
/*1ST LETS DEVELOPE THE USER DEFINE FUNCTION AND GET THE TOTAL FREIGHT COST
AND THEN WE WILL STORE IT INTO STORED PROCEDURE*/


SELECT * FROM FACT_FREIGHT_COST

CREATE FUNCTION DBO.GETTOTAL_FREIGHTCOST(
@MARKET VARCHAR(100),
@FISCALYEAR INT
)
RETURNS DECIMAL(18,2)
AS 
BEGIN 
DECLARE @TOTALFREIGHT_COST DECIMAL(18,2);
SELECT @TOTALFREIGHT_COST= SUM(TOTAL_FREIGHT_COST)
FROM FACT_FREIGHT_COST
WHERE MARKET= @MARKET AND FISCAL_YEAR= @FISCALYEAR;
RETURN ISNULL(@TOTALFREIGHT_COST,0);
END;
CREATE PROCEDURE UPDATE_TOTAL_FREIGHT_COST
(
@PRODUCTCODE VARCHAR(50),
@MARKET VARCHAR(50),
@FISCALYEAR INT
)
AS 
BEGIN 
DECLARE @FREIGHTCOST DECIMAL(18,2);

SET @FREIGHTCOST= DBO.GETTOTAL_FREIGHTCOST(@MARKET,@FISCALYEAR);
UPDATE FACT_MANUFACTURING_COST
SET OVERHEAD_COST= OVERHEAD_COST+@FREIGHTCOST
WHERE PRODUCT_CODE=@PRODUCTCODE AND FISCAL_YEAR=@FISCALYEAR;
PRINT 'OVERHEAD COST UPDATED WITH FREIGHT COST'+CAST(@FREIGHTCOST AS VARCHAR(50));
END;

EXEC dbo.UPDATE_TOTAL_FREIGHT_COST
    @ProductCode = 'P001',
    @Market = 'Asia',
    @FiscalYear = 2024;

SELECT * FROM FACT_FREIGHT_COST
WHERE FISCAL_YEAR = 2024;



/*12. Write a trigger that automatically updates the
inventory count in the product table whenever a new sale is
recorded, utilizing inbuilt functions to perform the
calculation.*/
SELECT * FROM DIM_PRODUCT

ALTER TABLE DIM_PRODUCT
ADD INVENTORY_COUNT INT;

CREATE TRIGGER TRIG_UPDATE_INVENTTABLE
ON FACT_SALES_MONTHLY
AFTER INSERT 
AS BEGIN
UPDATE DP
SET DP.INVENTORY_COUNT= DP.INVENTORY_COUNT-I.SOLD_QUANTITY
FROM DIM_PRODUCT DP
JOIN INSERTED I ON DP.PRODUCT_CODE= I.PRODUCT_CODE

PRINT 'INVENTORY UPDATED AFTER NEW SALES ENTERY';
END;

INSERT INTO FACT_SALES_MONTHLY (
    CUSTOMER_CODE, PRODUCT_CODE ,FISCAL_YEAR,MONTH,SOLD_QUANTITY,SALES_AMOUNT,SALES_DATE)
	VALUES
   ('C001', 'P001', 2024, 5, 100, 1000.00, '2024-05-01')



/*13. Implement a trigger to enforce referential integrity,
ensuring that only products listed in the product table can be
added to the sales table, utilizing subqueries to validate the
data.*/

SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM DIM_PRODUCT

CREATE TRIGGER TRG_CHECKPRODUCT_EXIT
ON FACT_SALES_MONTHLY
AFTER INSERT  AS 
BEGIN IF EXISTS
(
SELECT 1   --1 is a placeholder value. It just means: “We found a row.”
FROM INSERTED I WHERE NOT EXISTS
(
SELECT 1
FROM DIM_PRODUCT DP
WHERE DP.PRODUCT_CODE=I.PRODUCT_CODE))
BEGIN ROLLBACK TRANSACTION;   --Rollback the insert if product_code is invalid
--INFORM THE USERS
RAISERROR('INSERT FAILED: ONE OR MORE PRODUCT CODES DO NOT EXIT IN DIM_PRODUCT TABLE',16,1)
END
END;



INSERT INTO FACT_SALES_MONTHLY (
    CUSTOMER_CODE, PRODUCT_CODE ,FISCAL_YEAR,MONTH,SOLD_QUANTITY,SALES_AMOUNT,SALES_DATE)
	VALUES
   ('C001', 'P002', 2024, 5, 100, 1000.00, '2024-05-01')

/*14. Design a stored procedure to generate a report showing
the month-over-month growth rate of sales for each
product, using window functions to calculate the percentage
change.*/

CREATE PROCEDURE sp_MonthlySalesGrowthReport
AS
BEGIN
SELECT
product_code,
fiscal_year,
month,
sold_quantity,
LAG(sold_quantity) OVER (
PARTITION BY product_code, fiscal_year
ORDER BY month
 ) AS prev_month_quantity,
CASE 
WHEN LAG(sold_quantity) OVER (PARTITION BY product_code, fiscal_year ORDER BY month) IS NULL THEN NULL
WHEN LAG(sold_quantity) OVER (PARTITION BY product_code, fiscal_year ORDER BY month) = 0 THEN NULL
ELSE 
 ROUND(
 (CAST(sold_quantity AS FLOAT) - LAG(sold_quantity) OVER (PARTITION BY product_code, fiscal_year ORDER BY month)) * 100.0 /
 NULLIF(LAG(sold_quantity) OVER (PARTITION BY product_code, fiscal_year ORDER BY month), 0), 2
 )
END AS mom_growth_percentage
FROM fact_sales_monthly
ORDER BY product_code, fiscal_year, month;
END

EXEC sp_MonthlySalesGrowthReport;




/*15. Develop a user-defined function to calculate the
average discount percentage given to customers for a
specific product, utilizing inbuilt functions to aggregate and
analyze the data.*/


SELECT * FROM FACT_PRE_INVOICE_DEDUCTIONS

CREATE FUNCTION AVG_DISCOUNT
(
@PRODUCTCODE VARCHAR(50)
)
RETURNS DECIMAL (18,2)
AS BEGIN 
DECLARE @AVGDISCOUNT DECIMAL (18,2)
SELECT @AVGDISCOUNT= AVG(PRE_INVOICE_DISCOUNT) 
FROM FACT_PRE_INVOICE_DEDUCTIONS
WHERE PRODUCT_CODE=@PRODUCTCODE
RETURN ISNULL (@AVGDISCOUNT,0)
END;

SELECT DBO.AVG_DISCOUNT('P001') AS AVG_DISCOUNT_PERCENTAGE
SELECT * FROM FACT_PRE_INVOICE_DEDUCTIONS




SELECT * FROM DIM_CUSTOMER
SELECT * FROM DIM_PRODUCT
SELECT * FROM FACT_FORECAST_MONTHLY
SELECT * FROM FACT_FREIGHT_COST
SELECT * FROM FACT_GROSS_PRICE
SELECT * FROM FACT_MANUFACTURING_COST
SELECT * FROM FACT_POST_INVOICE_DEDUCTIONS
SELECT * FROM FACT_PRE_INVOICE_DEDUCTIONS
SELECT * FROM FACT_SALES_MONTHLY
SELECT * FROM FACT_CUSTOMER_FEEDBACK

/*16. Write a query to identify the customers who made the
highest total purchases in each region, using subqueries and
window functions to perform the analysis.*/
SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY

--CTE(COMMON TABLE EXPRESSOIN)
WITH CUSTOMER_SALES AS (
SELECT
DC.REGION, FSM.CUSTOMER_CODE, SUM(FSM.SALES_AMOUNT) AS TOTAL_SALES,
RANK() OVER(PARTITION BY DC.REGION ORDER BY  SUM(FSM.SALES_AMOUNT) DESC)
AS SALES_RANK
FROM FACT_SALES_MONTHLY FSM
INNER JOIN DIM_CUSTOMER DC 
ON FSM.CUSTOMER_CODE= DC.CUSTOMER_CODE
GROUP BY
DC.REGION, FSM.CUSTOMER_CODE)

SELECT REGION, CUSTOMER_CODE, TOTAL_SALES
FROM CUSTOMER_SALES
WHERE SALES_RANK=1
ORDER BY REGION

SELECT * FROM DIM_CUSTOMER
SELECT * FROM FACT_SALES_MONTHLY



/*17. Create a stored procedure to calculate the total revenue
generated from sales for a given period, using inbuilt
functions to handle date manipulation and aggregation.*/
SELECT * FROM FACT_SALES_MONTHLY

CREATE PROCEDURE TOTAL_REVENUE_FOR_PERIOD
@STARTDATE DATE,
@ENDDATE DATE
AS
BEGIN 
DECLARE @TOTAL_REVENUE DECIMAL(18,2);
SELECT @TOTAL_REVENUE = SUM(SALES_AMOUNT)
FROM FACT_SALES_MONTHLY
WHERE SALES_DATE BETWEEN @STARTDATE AND @ENDDATE;
 PRINT 'Total Revenue from ' + 
    CONVERT(VARCHAR, @StartDate) + ' to ' + CONVERT(VARCHAR, @EndDate) + 
    ' is: ' + CAST(ISNULL(@TOTAL_REVENUE, 0) AS VARCHAR(50));
END;


EXEC dbo.TOTAL_REVENUE_FOR_PERIOD 
    @StartDate = '2023-01-01', 
    @EndDate = '2023-12-31';

DROP PROCEDURE TOTAL_REVENUE_FOR_PERIOD
